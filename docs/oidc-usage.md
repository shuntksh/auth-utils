# Social Login Implementation Guide with Next.js App Router

This guide demonstrates how to implement Google OAuth2/OIDC social login using Next.js app router as a backend service.

## Understanding OpenID Connect (OIDC)

OpenID Connect (OIDC) is an identity layer built on top of the OAuth 2.0 protocol. While OAuth 2.0 is designed for authorization (granting access to resources), OIDC extends it to provide authentication (verifying user identity).

Key OIDC concepts:
- **ID Token**: A JWT (JSON Web Token) containing authenticated user information
- **UserInfo Endpoint**: An API that returns claims about the authenticated user
- **Discovery**: A mechanism to retrieve OIDC provider configuration
- **PKCE (Proof Key for Code Exchange)**: A security extension that prevents authorization code interception attacks

## Usage as a Library

The `@workspace/auth` package provides a comprehensive set of utilities for implementing OIDC authentication in your applications.

### Basic Usage

```typescript
import { OIDC, PKCE } from '@workspace/auth';

// 1. Configure your OIDC provider
const providerConfig = {
  provider: 'google',
  issuer: 'https://accounts.google.com',
  clientId: 'YOUR_CLIENT_ID',
  clientSecret: 'YOUR_CLIENT_SECRET',
  redirectUri: 'https://your-app.com/callback',
  authorizationEndpoint: 'https://accounts.google.com/o/oauth2/v2/auth',
  tokenEndpoint: 'https://oauth2.googleapis.com/token',
  userInfoEndpoint: 'https://openidconnect.googleapis.com/v1/userinfo',
  jwksUri: 'https://www.googleapis.com/oauth2/v3/certs',
  defaultScopes: ['openid', 'email', 'profile'],
  usePKCE: true
};

// 2. Generate PKCE parameters for enhanced security
const pkceParams = await PKCE.generate();
// Store codeVerifier securely for the callback

// 3. Generate authentication URL
const authUrl = OIDC.createAuthenticationUrl({
  config: providerConfig,
  state: 'random-state-value', // For CSRF protection
  nonce: 'random-nonce-value', // For replay protection
  pkce: pkceParams,
});

// 4. Redirect user to authUrl

// 5. Handle callback (in your callback route)
const { tokens, idTokenClaims } = await OIDC.handleAuthenticationResponse({
  config: providerConfig,
  code: 'authorization-code-from-callback',
  codeVerifier: pkceParams.codeVerifier,
  nonce: 'random-nonce-value',
});

// 6. Access user information
const userInfo = await OIDC.fetchUserInfo({
  config: providerConfig,
  accessToken: tokens.access_token,
});
```

## PKCE: Enhanced Security for Authorization Code Flow

PKCE (Proof Key for Code Exchange) is a security extension for OAuth 2.0 that protects authorization code flow from code interception attacks. It's particularly important for public clients (like SPAs and mobile apps) but provides additional security for all client types.

### Understanding PKCE

PKCE works by creating a cryptographic challenge during the authorization request that must be verified when exchanging the authorization code for tokens. This ensures that only the original client that initiated the authorization request can exchange the code for tokens, even if the code is intercepted.

Key components:
- **Code Verifier**: A high-entropy cryptographic random string generated by the client
- **Code Challenge**: Derived from the code verifier using a transformation method
- **Code Challenge Method**: The method used to derive the challenge (S256 or plain)

### Implementing PKCE with @workspace/auth

The library provides a comprehensive PKCE implementation that follows RFC 7636:

```typescript
import { PKCE } from '@workspace/auth';

// 1. Generate PKCE parameters
// This creates a code verifier and code challenge
const pkceParams = await PKCE.generate();
// Default is 128 characters with S256 method
// { codeVerifier, codeChallenge, codeChallengeMethod }

// 2. Store the code verifier securely
// This must be available during the callback phase
sessionStorage.setItem('pkce_code_verifier', pkceParams.codeVerifier);

// 3. Include PKCE parameters in the authorization request
const authUrl = OIDC.createAuthenticationUrl({
  config: providerConfig,
  state: crypto.randomUUID(),
  nonce: crypto.randomUUID(),
  pkce: pkceParams,
});

// 4. Redirect user to authUrl

// 5. During callback, retrieve the stored code verifier
const codeVerifier = sessionStorage.getItem('pkce_code_verifier');

// 6. Exchange the authorization code using the code verifier
const { tokens, idTokenClaims } = await OIDC.handleAuthenticationResponse({
  config: providerConfig,
  code: authorizationCode,
  codeVerifier,
  nonce: storedNonce,
});
```

### Remote Key Verification

When using PKCE with OIDC, token verification is a critical security step. The library supports remote key verification using the provider's JWKS (JSON Web Key Set):

```typescript
import { JWK, JWT } from '@workspace/auth';

// 1. Fetch the provider's JWKS
const jwks = await JWK.createRemoteKeySet(providerConfig.jwksUri);

// 2. Verify the ID token
const verificationResult = await JWT.verify({
  token: tokens.id_token,
  key: jwks,
  issuer: providerConfig.issuer,
  audience: providerConfig.clientId,
  clockTolerance: 60, // 60 seconds tolerance for clock skew
});

if (verificationResult.valid) {
  // Token is valid, use the claims
  const claims = verificationResult.payload;
  console.log('Authenticated user:', claims.sub);
} else {
  // Token validation failed
  console.error('Token validation failed:', verificationResult.error);
}
```

Alternatively, you can use the OIDC helper which handles both token exchange and verification:

```typescript
// This performs token exchange and verification in one step
const { tokens, idTokenClaims } = await OIDC.handleAuthenticationResponse({
  config: providerConfig,
  code: authorizationCode,
  codeVerifier,
  nonce: storedNonce,
  jwks, // Optional: provide pre-fetched JWKS
});

// idTokenClaims contains the verified claims
console.log('Authenticated user:', idTokenClaims.sub);
```

### Security Best Practices for PKCE

1. **Always use S256 method**: The plain method should only be used if S256 is not supported by the authorization server
2. **Generate cryptographically secure code verifiers**: Use the library's PKCE.generate() which creates high-entropy values
3. **Store code verifiers securely**: Use httpOnly cookies or secure session storage
4. **Verify tokens thoroughly**: Always validate signatures, issuer, audience, and expiration
5. **Implement proper state validation**: Use the state parameter alongside PKCE for CSRF protection
6. **Use nonce validation**: Include and verify the nonce claim to prevent replay attacks
7. **Implement proper error handling**: Handle verification failures securely

### Advanced Features

The library supports:

- **Token validation**: Verify ID tokens using JWK sets from the provider
- **PKCE flow**: Enhance security with code challenge and verifier
- **Refresh tokens**: Maintain long-lived sessions without re-authentication
- **Multiple providers**: Support various OIDC providers with minimal configuration changes
